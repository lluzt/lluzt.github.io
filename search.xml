<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java SharedSecret类</title>
      <link href="/2019/09/05/Java-SharedSecret%E7%B1%BB/"/>
      <url>/2019/09/05/Java-SharedSecret%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK-SharedSecret类"><a href="#JDK-SharedSecret类" class="headerlink" title="JDK  SharedSecret类"></a>JDK  SharedSecret类</h1><h2 id="JavaLangAccess"><a href="#JavaLangAccess" class="headerlink" title="JavaLangAccess"></a>JavaLangAccess</h2><h3 id="获取Java栈帧信息"><a href="#获取Java栈帧信息" class="headerlink" title="获取Java栈帧信息"></a>获取Java栈帧信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JavaLangAccess access = SharedSecrets.getJavaLangAccess();</span><br><span class="line">Throwable throwable = new Throwable();</span><br><span class="line"></span><br><span class="line">int depth = access.getStackTraceDepth(throwable);</span><br><span class="line"></span><br><span class="line">//输出JVM栈帧中的所有类实例</span><br><span class="line">for (int i = 0; i &lt; depth; i++) &#123;</span><br><span class="line">    StackTraceElement frame = access.getStackTraceElement(throwable, i);</span><br><span class="line">    System.out.println(frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JDK Reference</title>
      <link href="/2019/09/04/Java-Reference%E7%B1%BB/"/>
      <url>/2019/09/04/Java-Reference%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK-Reference"><a href="#JDK-Reference" class="headerlink" title="JDK Reference"></a>JDK Reference</h1><p>Java目前有4中引用类型：</p><p>强引用(Strong Reference)：普通的的引用类型，new一个对象默认得到的引用就是强引用，只要对象存在强引用，就不会被GC。<br>软引用(Soft Reference)：相对较弱的引用，垃圾回收器会在内存不足时回收弱引用指向的对象。JVM会在抛出OOME前清理所有弱引用指向的对象，如果清理完还是内存不足，才会抛出OOME。所以软引用一般用于实现内存敏感缓存。<br>弱引用(Weak Reference)：更弱的引用类型，垃圾回收器在GC时会回收此对象，也可以用于实现缓存，比如JDK提供的WeakHashMap。<br>虚引用(Phantom Reference)：一种特殊的引用类型，不能通过虚引用获取到关联对象，只是用于获取对象被回收的通知。</p><p>Reference是所有引用类型的父类，定义了引用的公共行为和操作。<br><img src="/images/reference.png" alt></p><h2 id="Reference-构造函数"><a href="#Reference-构造函数" class="headerlink" title="Reference 构造函数"></a>Reference 构造函数</h2><p>Reference类中有两个构造函数，一个需要传入引用队列，另一个则不需要。</p><p>这个队列的意义在于增加一种判断机制，可以在外部通过监控这个队列来判断对象是否被回收。如果一个对象即将被回收，那么引用这个对象的reference对象就会被放到这个队列中。通过监控这个队列，就可以取出这个reference后再进行一些善后处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Reference(T referent) &#123;</span><br><span class="line">    this(referent, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reference(T referent, ReferenceQueue&lt;? super T&gt; queue) &#123;</span><br><span class="line">    this.referent = referent;</span><br><span class="line">    this.queue = (queue == null) ? ReferenceQueue.NULL : queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> volatile ReferenceQueue&lt;? super T&gt; queue;</span><br><span class="line"></span><br><span class="line">/* When active:   NULL</span><br><span class="line"> *     pending:   this</span><br><span class="line"> *    Enqueued:   next reference in queue (or this if last)</span><br><span class="line"> *    Inactive:   this</span><br><span class="line"> */</span><br><span class="line">@SuppressWarnings(&quot;rawtypes&quot;)</span><br><span class="line">volatile Reference next;</span><br></pre></td></tr></table></figure><h2 id="Reference-状态"><a href="#Reference-状态" class="headerlink" title="Reference 状态"></a>Reference 状态</h2><p>在Reference类中，有一段很长的注释，来对内部对象referent的状态进行了说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Active:</span><br><span class="line">reference如果处于此状态，会受到垃圾处理器的特殊处理。当垃圾回收器检测到referent已经更改为合适的状态后(没有任何强引用和软引用关联)，会在某个时间将实例的状态更改为Pending或者Inactive。具体取决于实例是否在创建时注册到一个引用队列中。</span><br><span class="line">在前一种情况下（将状态更改为Pending），他还会将实例添加到pending-Reference列表中。新创建的实例处于活动状态。</span><br><span class="line"></span><br><span class="line">Pending:</span><br><span class="line">实例如果处于此状态，表明它是pending-Reference列表中的一个元素，等待被Reference-handler线程做入队处理。未注册引用队列的实例永远不会处于该状态。</span><br><span class="line"></span><br><span class="line">Enqueued:</span><br><span class="line">实例如果处于此状态，表明它已经是它注册的引用队列中的一个元素，当它被从引用队列中移除时，它的状态将会变为Inactive，未注册引用队列的实例永远不会处于该状态。</span><br><span class="line"></span><br><span class="line">Inactive:</span><br><span class="line">实例如果处于此状态，它的状态将永远不会再改变了。</span><br></pre></td></tr></table></figure><p>JVM中并没有显示定义这样的状态，而是通过next和queue来进行判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Active：如果创建Reference对象时，没有传入ReferenceQueue，queue=ReferenceQueue.NULL。如果有传入，则queue指向传入的ReferenceQueue队列对象。next == null；</span><br><span class="line"></span><br><span class="line">Pending：queue为初始化时传入ReferenceQueue对象；next == this；</span><br><span class="line"></span><br><span class="line">Enqueue：queue == ReferenceQueue.ENQUEUED；next为queue中下一个reference对象，或者若为最后一个了next == this；</span><br><span class="line"></span><br><span class="line">Inactive：queue == ReferenceQueue.NULL; next == this.</span><br><span class="line">如果next==null，则reference处于Active状态；</span><br><span class="line"></span><br><span class="line">如果next!=null，queue == ReferenceQueue.NULL，则reference处于Inactive状态；</span><br><span class="line"></span><br><span class="line">如果next!=null，queue == ReferenceQueue.ENQUEUED，则reference处于Enqueue状态；</span><br><span class="line"></span><br><span class="line">如果next != null，queue != ReferenceQueue.NULL &amp;&amp; queu != ReferenceQueue.ENQUEUED ，则reference处于Pending状态。</span><br></pre></td></tr></table></figure><p><img src="/images/reference-schedule.png" alt></p><p>reference引用的对象被回收后，垃圾回收器把Reference添加到pending-Reference链表中(Reference对象中有一个pending成员变量，是静态变量，它就是这个pending-Reference链表的头结点。要组成链表，还需要一个指针，指向下一个节点，这个对应的是java.lang.ref.Reference#discovered这个成员变量)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* When active:   next element in a discovered reference list maintained by GC (or this if last)</span><br><span class="line"> *     pending:   next element in the pending list (or null if last)</span><br><span class="line"> *   otherwise:   NULL</span><br><span class="line"> */</span><br><span class="line">transient private Reference&lt;T&gt; discovered;  /* used by VM */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Object used to synchronize with the garbage collector.  The collector</span><br><span class="line"> * must acquire this lock at the beginning of each collection cycle.  It is</span><br><span class="line"> * therefore critical that any code holding this lock complete as quickly</span><br><span class="line"> * as possible, allocate no new objects, and avoid calling user code.</span><br><span class="line"> */</span><br><span class="line">static private class Lock &#123; &#125;</span><br><span class="line">private static Lock lock = new Lock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* List of References waiting to be enqueued.  The collector adds</span><br><span class="line"> * References to this list, while the Reference-handler thread removes</span><br><span class="line"> * them.  This list is protected by the above lock object. The</span><br><span class="line"> * list uses the discovered field to link its elements.</span><br><span class="line"> */</span><br><span class="line">private static Reference&lt;Object&gt; pending = null;</span><br></pre></td></tr></table></figure><h2 id="ReferenceHandler线程"><a href="#ReferenceHandler线程" class="headerlink" title="ReferenceHandler线程"></a>ReferenceHandler线程</h2><p>Reference类中有一个特殊的线程叫ReferenceHandler，专门处理那些pending链表中的引用对象。ReferenceHandler类是Reference类的一个静态内部类，继承自Thread，所以这条线程就叫它ReferenceHandler线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">private static class ReferenceHandler extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    private static void ensureClassInitialized(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(clazz.getName(), true, clazz.getClassLoader());</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            throw (Error) new NoClassDefFoundError(e.getMessage()).initCause(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        // pre-load and initialize InterruptedException and Cleaner classes</span><br><span class="line">        // so that we don&apos;t get into trouble later in the run loop if there&apos;s</span><br><span class="line">        // memory shortage while loading/initializing them lazily.</span><br><span class="line">        ensureClassInitialized(InterruptedException.class);</span><br><span class="line">        ensureClassInitialized(Cleaner.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">        super(g, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            tryHandlePending(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Try handle pending &#123;@link Reference&#125; if there is one.&lt;p&gt;</span><br><span class="line"> * Return &#123;@code true&#125; as a hint that there might be another</span><br><span class="line"> * &#123;@link Reference&#125; pending or &#123;@code false&#125; when there are no more pending</span><br><span class="line"> * &#123;@link Reference&#125;s at the moment and the program can do some other</span><br><span class="line"> * useful work instead of looping.</span><br><span class="line"> *</span><br><span class="line"> * @param waitForNotify if &#123;@code true&#125; and there was no pending</span><br><span class="line"> *                      &#123;@link Reference&#125;, wait until notified from VM</span><br><span class="line"> *                      or interrupted; if &#123;@code false&#125;, return immediately</span><br><span class="line"> *                      when there is no pending &#123;@link Reference&#125;.</span><br><span class="line"> * @return &#123;@code true&#125; if there was a &#123;@link Reference&#125; pending and it</span><br><span class="line"> *         was processed, or we waited for notification and either got it</span><br><span class="line"> *         or thread was interrupted before being notified;</span><br><span class="line"> *         &#123;@code false&#125; otherwise.</span><br><span class="line"> */</span><br><span class="line">static boolean tryHandlePending(boolean waitForNotify) &#123;</span><br><span class="line">    Reference&lt;Object&gt; r;</span><br><span class="line">    Cleaner c;</span><br><span class="line">    try &#123;</span><br><span class="line">        synchronized (lock) &#123;</span><br><span class="line">            if (pending != null) &#123;</span><br><span class="line">                r = pending;</span><br><span class="line">                // &apos;instanceof&apos; might throw OutOfMemoryError sometimes</span><br><span class="line">                // so do this before un-linking &apos;r&apos; from the &apos;pending&apos; chain...</span><br><span class="line">                c = r instanceof Cleaner ? (Cleaner) r : null;</span><br><span class="line">                // unlink &apos;r&apos; from &apos;pending&apos; chain</span><br><span class="line">                pending = r.discovered;</span><br><span class="line">                r.discovered = null;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // The waiting on the lock may cause an OutOfMemoryError</span><br><span class="line">                // because it may try to allocate exception objects.</span><br><span class="line">                if (waitForNotify) &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                // retry if waited</span><br><span class="line">                return waitForNotify;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (OutOfMemoryError x) &#123;</span><br><span class="line">        // Give other threads CPU time so they hopefully drop some live references</span><br><span class="line">        // and GC reclaims some space.</span><br><span class="line">        // Also prevent CPU intensive spinning in case &apos;r instanceof Cleaner&apos; above</span><br><span class="line">        // persistently throws OOME for some time...</span><br><span class="line">        Thread.yield();</span><br><span class="line">        // retry</span><br><span class="line">        return true;</span><br><span class="line">    &#125; catch (InterruptedException x) &#123;</span><br><span class="line">        // retry</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Fast path for cleaners</span><br><span class="line">    if (c != null) &#123;</span><br><span class="line">        c.clean();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReferenceQueue&lt;? super Object&gt; q = r.queue;</span><br><span class="line">    if (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReferenceHandler线程是在Reference的static块中启动的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class="line">    for (ThreadGroup tgn = tg;</span><br><span class="line">         tgn != null;</span><br><span class="line">         tg = tgn, tgn = tg.getParent());</span><br><span class="line">    Thread handler = new ReferenceHandler(tg, &quot;Reference Handler&quot;);</span><br><span class="line">    /* If there were a special system-only priority greater than</span><br><span class="line">     * MAX_PRIORITY, it would be used here</span><br><span class="line">     */</span><br><span class="line">    handler.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">    handler.setDaemon(true);</span><br><span class="line">    handler.start();</span><br><span class="line"></span><br><span class="line">    // provide access in SharedSecrets</span><br><span class="line">    SharedSecrets.setJavaLangRefAccess(new JavaLangRefAccess() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean tryHandlePendingReference() &#123;</span><br><span class="line">            return tryHandlePending(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://imushan.com/2018/08/19/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-Reference/" target="_blank" rel="noopener">http://imushan.com/2018/08/19/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-Reference/</a><br><a href="https://www.cnblogs.com/mfrank/p/9843489.html" target="_blank" rel="noopener">https://www.cnblogs.com/mfrank/p/9843489.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Unsafe类</title>
      <link href="/2019/09/04/Java-Unsafe%E7%B1%BB/"/>
      <url>/2019/09/04/Java-Unsafe%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-Unsafe类"><a href="#Java-Unsafe类" class="headerlink" title="Java Unsafe类"></a>Java Unsafe类</h1><p>Unsafe类是在sun.misc包下，不属于Java标准。但是很多Java的基础类库，包括一些被广泛使用的高性能开发库都是基于Unsafe类开发的，比如Netty、Cassandra、Hadoop、Kafka等。Unsafe类在提升Java运行效率，增强Java语言底层操作能力方面起了很大的作用。<br>Unsafe类使Java拥有了像C语言的指针一样操作内存空间的能力，同时也带来了指针的问题。过度的使用Unsafe类会使得出错的几率变大，因此Java官方并不建议使用。该类的大部分方法均为 native 修饰，即为直接调用的其它语言(大多为 C++)编写的方法来进行操作。</p><h2 id="获取Unsafe实例"><a href="#获取Unsafe实例" class="headerlink" title="获取Unsafe实例"></a>获取Unsafe实例</h2><p>如下Unsafe源码所示，Unsafe类为一单例实现，提供静态方法getUnsafe获取Unsafe实例，当且仅当调用getUnsafe方法的类为引导类加载器所加载时才合法，否则抛出SecurityException异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public final class Unsafe &#123;</span><br><span class="line">    private static final Unsafe theUnsafe;</span><br><span class="line"></span><br><span class="line">    private Unsafe() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @CallerSensitive</span><br><span class="line">    public static Unsafe getUnsafe() &#123;</span><br><span class="line">        Class var0 = Reflection.getCallerClass();</span><br><span class="line">        if (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">            throw new SecurityException(&quot;Unsafe&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return theUnsafe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引导类加载器加载"><a href="#引导类加载器加载" class="headerlink" title="引导类加载器加载"></a>引导类加载器加载</h3><p>通过Java命令行命令-Xbootclasspath/a把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载，从而通过Unsafe.getUnsafe方法安全的获取Unsafe实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xbootclasspath/a: $&#123;path&#125;   // 其中path为调用Unsafe相关方法的类所在jar包路径</span><br></pre></td></tr></table></figure><h3 id="通过反射获取单例对象theUnsafe"><a href="#通过反射获取单例对象theUnsafe" class="headerlink" title="通过反射获取单例对象theUnsafe"></a>通过反射获取单例对象theUnsafe</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static Unsafe reflectGetUnsafe() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">      field.setAccessible(true);</span><br><span class="line">      return (Unsafe) field.get(null);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      log.error(e.getMessage(), e);</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h2><p><img src="/images/unsafe.png" alt></p><h3 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h3><p>内存操作这部分主要包含堆外内存的分配、拷贝、释放、给定地址值操作等方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//分配内存, 相当于C++的malloc函数</span><br><span class="line">public native long allocateMemory(long bytes);</span><br><span class="line">//扩充内存</span><br><span class="line">public native long reallocateMemory(long address, long bytes);</span><br><span class="line">//释放内存</span><br><span class="line">public native void freeMemory(long address);</span><br><span class="line">//在给定的内存块中设置值</span><br><span class="line">public native void setMemory(Object o, long offset, long bytes, byte value);</span><br><span class="line">//内存拷贝</span><br><span class="line">public native void copyMemory(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);</span><br><span class="line">//获取给定地址值，忽略修饰限定符的访问限制。与此类似操作还有: getInt，getDouble，getLong，getChar等</span><br><span class="line">public native Object getObject(Object o, long offset);</span><br><span class="line">//为给定地址设置值，忽略修饰限定符的访问限制，与此类似操作还有: putInt,putDouble，putLong，putChar等</span><br><span class="line">public native void putObject(Object o, long offset, Object x);</span><br><span class="line">//获取给定地址的byte类型的值（当且仅当该内存地址为allocateMemory分配时，此方法结果为确定的）</span><br><span class="line">public native byte getByte(long address);</span><br><span class="line">//为给定地址设置byte类型的值（当且仅当该内存地址为allocateMemory分配时，此方法结果才是确定的）</span><br><span class="line">public native void putByte(long address, byte x);</span><br></pre></td></tr></table></figure><p>通常，我们在Java中创建的对象都处于堆内内存（heap）中，堆内内存是由JVM所管控的Java进程内存，并且它们遵循JVM的内存管理机制，JVM会采用垃圾回收机制统一管理堆内存。与之相对的是堆外内存，存在于JVM管控之外的内存区域，Java中对堆外内存的操作，依赖于Unsafe提供的操作堆外内存的native方法。</p><h4 id="使用堆外内存的原因"><a href="#使用堆外内存的原因" class="headerlink" title="使用堆外内存的原因"></a>使用堆外内存的原因</h4><p>对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在GC时减少回收停顿对于应用的影响。<br>提升程序I/O操作的性能。通常在I/O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</p><h4 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h4><p>DirectByteBuffer是Java用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在Netty、MINA等NIO框架中应用广泛。DirectByteBuffer对于堆外内存的创建、使用、销毁等逻辑均由Unsafe提供的堆外内存API来实现。<br>下图为DirectByteBuffer构造函数，创建DirectByteBuffer的时候，通过Unsafe.allocateMemory分配内存、Unsafe.setMemory进行内存初始化，而后构建Cleaner对象用于跟踪DirectByteBuffer对象的垃圾回收，以实现当DirectByteBuffer被垃圾回收时，分配的堆外内存一起被释放。<br><img src="/images/DirectByteBuffer.png" alt><br>那么如何通过构建垃圾回收追踪对象Cleaner实现堆外内存释放呢？Cleaner继承自Java四大引用类型之一的虚引用PhantomReference（众所周知，无法通过虚引用获取与之关联的对象实例，且当对象仅被虚引用引用时，在任何发生GC的时候，其均可被回收），通常PhantomReference与引用队列ReferenceQueue结合使用，可以实现虚引用关联对象被垃圾回收时能够进行系统通知、资源清理等功能。<br><img src="/images/bufferAllocation.png" alt><br>当某个被Cleaner引用的对象将被回收时，JVM垃圾收集器会将此对象的引用放入到对象引用中的pending链表中，等待Reference-Handler进行相关处理。其中，Reference-Handler为一个拥有最高优先级的守护线程，会循环不断的处理pending链表中的对象引用，执行Cleaner的clean方法进行相关清理工作。所以当DirectByteBuffer仅被Cleaner引用（即为虚引用）时，其可以在任意GC时段被回收。当DirectByteBuffer实例对象被回收时，在Reference-Handler线程操作中，会调用Cleaner的clean方法根据创建Cleaner时传入的Deallocator来进行堆外内存的释放。</p><h3 id="CAS相关"><a href="#CAS相关" class="headerlink" title="CAS相关"></a>CAS相关</h3><p>如下源代码释义所示，这部分主要为CAS相关操作的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  *  CAS</span><br><span class="line">  * @param o         包含要修改field的对象</span><br><span class="line">  * @param offset    对象中某field的偏移量</span><br><span class="line">  * @param expected  期望值</span><br><span class="line">  * @param update    更新值</span><br><span class="line">  * @return          true | false</span><br><span class="line">  */</span><br><span class="line">public final native boolean compareAndSwapObject(Object o, long offset,  Object expected, Object update);</span><br><span class="line"></span><br><span class="line">public final native boolean compareAndSwapInt(Object o, long offset, int expected,int update);</span><br><span class="line">  </span><br><span class="line">public final native boolean compareAndSwapLong(Object o, long offset, long expected, long update);</span><br></pre></td></tr></table></figure><p>CAS是一条CPU的原子指令（cmpxchg指令），不会造成所谓的数据不一致问题，Unsafe提供的CAS方法（如compareAndSwapXXX）底层实现即为CPU指令cmpxchg</p><h4 id="典型应用-1"><a href="#典型应用-1" class="headerlink" title="典型应用"></a>典型应用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>CAS在java.util.concurrent.atomic相关类、Java AQS、CurrentHashMap等实现上有非常广泛的应用。如下图所示，AtomicInteger的实现中，静态字段valueOffset即为字段value的内存偏移地址，valueOffset的值在AtomicInteger初始化时，在静态代码块中通过Unsafe的objectFieldOffset方法获取。在AtomicInteger中提供的线程安全方法中，通过字段valueOffset的值可以定位到AtomicInteger对象中value的内存地址，从而可以根据CAS实现对value字段的原子操作。下图为某个AtomicInteger对象自增操作前后的内存示意图，对象的基地址baseAddress=“0x110000”，通过baseAddress+valueOffset得到value的内存地址valueAddress=“0x11000c”；然后通过CAS进行原子性的更新操作，成功则返回，否则继续重试，直到更新成功为止。线程调度这部分，包括线程挂起、恢复、锁机制等方法。//取消阻塞线程<br>public native void unpark(Object thread);<br>//阻塞线程<br>public native void park(boolean isAbsolute, long time);<br>//获得对象锁（可重入锁）<br>@Deprecated<br>public native void monitorEnter(Object o);<br>//释放对象锁<br>@Deprecated<br>public native void monitorExit(Object o);<br>//尝试获取对象锁<br>@Deprecated<br>public native boolean tryMonitorEnter(Object o);<br>复制代码如上源码说明中，方法park、unpark即可实现线程的挂起与恢复，将一个线程进行挂起是通过park方法实现的，调用park方法后，线程将一直阻塞直到超时或者中断等条件出现；unpark可以终止一个挂起的线程，使其恢复正常。典型应用Java锁和同步器框架的核心类AbstractQueuedSynchronizer，就是通过调用LockSupport.park()和LockSupport.unpark()实现线程的阻塞和唤醒的，而LockSupport的park、unpark方法实际是调用Unsafe的park、unpark方式来实现。Class相关此部分主要提供Class和它的静态字段的操作相关方法，包含静态字段内存定位、定义类、定义匿名类、检验&amp;确保初始化等。//获取给定静态字段的内存地址偏移量，这个值对于给定的字段是唯一且固定不变的<br>public native long staticFieldOffset(Field f);<br>//获取一个静态类中给定字段的对象指针<br>public native Object staticFieldBase(Field f);<br>//判断是否需要初始化一个类，通常在获取一个类的静态属性的时候（因为一个类如果没初始化，它的静态属性也不会初始化）使用。 当且仅当ensureClassInitialized方法不生效时返回false。<br>public native boolean shouldBeInitialized(Class<?> c);//检测给定的类是否已经初始化。通常在获取一个类的静态属性的时候（因为一个类如果没初始化，它的静态属性也不会初始化）使用。public native void ensureClassInitialized(Class<?> c);<br>//定义一个类，此方法会跳过JVM的所有安全检查，默认情况下，ClassLoader（类加载器）和ProtectionDomain（保护域）实例来源于调用者<br>public native Class<?> defineClass(String name, byte[] b, int off, int len, ClassLoader loader, ProtectionDomain protectionDomain);//定义一个匿名类public native Class<?> defineAnonymousClass(Class<?> hostClass, byte[] data, Object[] cpPatches);复制代码典型应用从Java 8开始，JDK使用invokedynamic及VM Anonymous Class结合来实现Java语言层面上的Lambda表达式。invokedynamic： invokedynamic是Java 7为了实现在JVM上运行动态语言而引入的一条新的虚拟机指令，它可以实现在运行期动态解析出调用点限定符所引用的方法，然后再执行该方法，invokedynamic指令的分派逻辑是由用户设定的引导方法决定。VM Anonymous Class：可以看做是一种模板机制，针对于程序动态生成很多结构相同、仅若干常量不同的类时，可以先创建包含常量占位符的模板类，而后通过Unsafe.defineAnonymousClass方法定义具体类时填充模板的占位符生成具体的匿名类。生成的匿名类不显式挂在任何ClassLoader下面，只要当该类没有存在的实例对象、且没有强引用来引用该类的Class对象时，该类就会被GC回收。故而VM Anonymous Class相比于Java语言层面的匿名内部类无需通过ClassClassLoader进行类加载且更易回收。在Lambda表达式实现中，通过invokedynamic指令调用引导方法生成调用点，在此过程中，会通过ASM动态生成字节码，而后利用Unsafe的defineAnonymousClass方法定义实现相应的函数式接口的匿名类，然后再实例化此匿名类，并返回与此匿名类中函数式方法的方法句柄关联的调用点；而后可以通过此调用点实现调用相应Lambda表达式定义逻辑的功能。下面以如下图所示的Test类来举例说明。Test类编译后的class文件反编译后的结果如下图一所示（删除了对本文说明无意义的部分），我们可以从中看到main方法的指令实现、invokedynamic指令调用的引导方法BootstrapMethods、及静态方法lambda$main$0（实现了Lambda表达式中字符串打印逻辑）等。在引导方法执行过程中，会通过Unsafe.defineAnonymousClass生成如下图二所示的实现Consumer接口的匿名类。其中，accept方法通过调用Test类中的静态方法lambda$main$0来实现Lambda表达式中定义的逻辑。而后执行语句consumer.accept（"lambda"）其实就是调用下图二所示的匿名类的accept方法。对象操作此部分主要包含对象成员属性相关操作及非常规的对象实例化方式等相关方法。//返回对象成员属性在内存地址相对于此对象的内存地址的偏移量public native long objectFieldOffset(Field f);//获得给定对象的指定地址偏移量的值，与此类似操作还有：getInt，getDouble，getLong，getChar等public native Object getObject(Object o, long offset);//给定对象的指定地址偏移量设值，与此类似操作还有：putInt，putDouble，putLong，putChar等public native void putObject(Object o, long offset, Object x);//从对象的指定偏移量处获取变量的引用，使用volatile的加载语义public native Object getObjectVolatile(Object o, long offset);//存储变量的引用到对象的指定的偏移量处，使用volatile的存储语义public native void putObjectVolatile(Object o, long offset, Object x);//有序、延迟版本的putObjectVolatile方法，不保证值的改变被其他线程立即看到。只有在field被volatile修饰符修饰时有效public native void putOrderedObject(Object o, long offset, Object x);//绕过构造方法、初始化代码来创建对象public native Object allocateInstance(Class<?> cls) throws InstantiationException;<br>复制代码典型应用常规对象实例化方式：我们通常所用到的创建对象的方式，从本质上来讲，都是通过new机制来实现对象的创建。但是，new机制有个特点就是当类只提供有参的构造函数且无显示声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。非常规的实例化方式：而Unsafe中提供allocateInstance方法，仅通过Class对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM安全检查等。它抑制修饰符检测，也就是即使构造器是private修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance在java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用。如下图所示，在Gson反序列化时，如果类有默认构造函数，则通过反射调用默认构造函数创建实例，否则通过UnsafeAllocator来实现对象实例的构造，UnsafeAllocator通过调用Unsafe的allocateInstance实现对象的实例化，保证在目标类无默认构造函数时，反序列化不够影响。数组相关这部分主要介绍与数据操作相关的arrayBaseOffset与arrayIndexScale这两个方法，两者配合起来使用，即可定位数组中每个元素在内存中的位置。//返回数组中第一个元素的偏移地址<br>public native int arrayBaseOffset(Class<?> arrayClass);//返回数组中一个元素占用的大小public native int arrayIndexScale(Class<?> arrayClass);<br>复制代码典型应用这两个与数据操作相关的方法，在java.util.concurrent.atomic 包下的AtomicIntegerArray（可以实现对Integer数组中每个元素的原子性操作）中有典型的应用，如下图AtomicIntegerArray源码所示，通过Unsafe的arrayBaseOffset、arrayIndexScale分别获取数组首元素的偏移地址base及单个元素大小因子scale。后续相关原子性操作，均依赖于这两个值进行数组中元素的定位，如下图二所示的getAndAdd方法即通过checkedByteOffset方法获取某数组元素的偏移地址，而后通过CAS实现原子性操作。内存屏障在Java 8中引入，用于定义内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前<br>public native void loadFence();<br>//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前<br>public native void storeFence();<br>//内存屏障，禁止load、store操作重排序<br>public native void fullFence();<br>复制代码典型应用在Java 8中引入了一种锁的新机制——StampedLock，它可以看成是读写锁的一个改进版本。StampedLock提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于StampedLock提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存load到线程工作内存时，会存在数据不一致问题，所以当使用StampedLock的乐观读锁时，需要遵从如下图用例中使用的模式来确保数据的一致性。如上图用例所示计算坐标点Point对象，包含点移动方法move及计算此点到原点的距离的方法distanceFromOrigin。在方法distanceFromOrigin中，首先，通过tryOptimisticRead方法获取乐观读标记；然后从主内存中加载点的坐标值 (x,y)；而后通过StampedLock的validate方法校验锁状态，判断坐标点(x,y)从主内存加载到线程工作内存过程中，主内存的值是否已被其他线程通过move方法修改，如果validate返回值为true，证明(x, y)的值未被修改，可参与后续计算；否则，需加悲观读锁，再次从主内存加载(x,y)的最新值，然后再进行距离计算。其中，校验锁状态这步操作至关重要，需要判断锁状态是否发生改变，从而判断之前copy到线程工作内存中的值是否与主内存的值存在不一致。下图为StampedLock.validate方法的源码实现，通过锁标记与相关常量进行位运算、比较来校验锁状态，在校验逻辑之前，会通过Unsafe的loadFence方法加入一个load内存屏障，目的是避免上图用例中步骤②和StampedLock.validate中锁状态校验运算发生重排序导致锁状态校验不准确的问题。系统相关这部分包含两个获取系统相关信息的方法。//返回系统指针的大小。返回值为4（32位系统）或 8（64位系统）。<br>public native int addressSize();<br>//内存页的大小，此值为2的幂次方。<br>public native int pageSize();<br>复制代码典型应用如下图所示的代码片段，为java.nio下的工具类Bits中计算待申请内存所需内存页数量的静态方法，其依赖于Unsafe中pageSize方法获取系统内存页大小实现后续计算逻辑。</p><p>作者：我是月亮呀<br>链接：<a href="https://juejin.im/post/5d0651edf265da1bd3055891" target="_blank" rel="noopener">https://juejin.im/post/5d0651edf265da1bd3055891</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br>一、内存管理。包括分配内存、释放内存等。</p><p>该部分包括了allocateMemory（分配内存）、reallocateMemory（重新分配内存）、copyMemory（拷贝内存）、freeMemory（释放内存 ）、getAddress（获取内存地址）、addressSize、pageSize、getInt（获取内存地址指向的整数）、getIntVolatile（获取内存地址指向的整数，并支持volatile语义）、putInt（将整数写入指定内存地址）、putIntVolatile（将整数写入指定内存地址，并支持volatile语义）、putOrderedInt（将整数写入指定内存地址、有序或者有延迟的方法）等方法。getXXX和putXXX包含了各种基本类型的操作。</p><p>利用copyMemory方法，我们可以实现一个通用的对象拷贝方法，无需再对每一个对象都实现clone方法，当然这通用的方法只能做到对象浅拷贝。</p><p>二、非常规的对象实例化。</p><p>allocateInstance()方法提供了另一种创建实例的途径。通常我们可以用new或者反射来实例化对象，使用allocateInstance()方法可以直接生成对象实例，且无需调用构造方法和其它初始化方法。</p><p>这在对象反序列化的时候会很有用，能够重建和设置final字段，而不需要调用构造方法。</p><p>三、操作类、对象、变量。</p><p>这部分包括了staticFieldOffset（静态域偏移）、defineClass（定义类）、defineAnonymousClass（定义匿名类）、ensureClassInitialized（确保类初始化）、objectFieldOffset（对象域偏移）等方法。</p><p>通过这些方法我们可以获取对象的指针，通过对指针进行偏移，我们不仅可以直接修改指针指向的数据（即使它们是私有的），甚至可以找到JVM已经认定为垃圾、可以进行回收的对象。</p><p>四、数组操作。</p><p>这部分包括了arrayBaseOffset（获取数组第一个元素的偏移地址）、arrayIndexScale（获取数组中元素的增量地址）等方法。arrayBaseOffset与arrayIndexScale配合起来使用，就可以定位数组中每个元素在内存中的位置。</p><p>由于Java的数组最大值为Integer.MAX_VALUE，使用Unsafe类的内存分配方法可以实现超大数组。实际上这样的数据就可以认为是C数组，因此需要注意在合适的时间释放内存。</p><p>五、多线程同步。包括锁机制、CAS操作等。</p><p>这部分包括了monitorEnter、tryMonitorEnter、monitorExit、compareAndSwapInt、compareAndSwap等方法。</p><p>其中monitorEnter、tryMonitorEnter、monitorExit已经被标记为deprecated，不建议使用。</p><p>Unsafe类的CAS操作可能是用的最多的，它为Java的锁机制提供了一种新的解决办法，比如AtomicInteger等类都是通过该方法来实现的。compareAndSwap方法是原子的，可以避免繁重的锁机制，提高代码效率。这是一种乐观锁，通常认为在大部分情况下不出现竞态条件，如果操作失败，会不断重试直到成功。</p><p>六、挂起与恢复。</p><p>这部分包括了park、unpark等方法。</p><p>将一个线程进行挂起是通过park方法实现的，调用 park后，线程将一直阻塞直到超时或者中断等条件出现。unpark可以终止一个挂起的线程，使其恢复正常。整个并发框架中对线程的挂起操作被封装在 LockSupport类中，LockSupport类中有各种版本pack方法，但最终都调用了Unsafe.park()方法。</p><p>七、内存屏障。</p><p>这部分包括了loadFence、storeFence、fullFence等方法。这是在Java 8新引入的，用于定义内存屏障，避免代码重排序。</p><p>loadFence() 表示该方法之前的所有load操作在内存屏障之前完成。同理storeFence()表示该方法之前的所有store操作在内存屏障之前完成。fullFence()表示该方法之前的所有load、store操作在内存屏障之前完成。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/pkufork/p/java_unsafe.html" target="_blank" rel="noopener">https://www.cnblogs.com/pkufork/p/java_unsafe.html</a><br><a href="https://juejin.im/post/5d0651edf265da1bd3055891" target="_blank" rel="noopener">https://juejin.im/post/5d0651edf265da1bd3055891</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java  日志框架机制</title>
      <link href="/2019/08/30/Java-%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/08/30/Java-%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-框架机制"><a href="#Java-框架机制" class="headerlink" title="Java  框架机制"></a>Java  框架机制</h1><h2 id="SLF4J-LogBack"><a href="#SLF4J-LogBack" class="headerlink" title="SLF4J + LogBack"></a>SLF4J + LogBack</h2><p>最流行的日志框架解决方案SLF4J + LogBack</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 内核重写、测试充分、初始化内存加载更小，这一切让logback性能和log4j相比有诸多倍的提升</span><br><span class="line">* logback有比较齐全的文档</span><br><span class="line">* logback当配置文件修改了，支持自动重新加载配置文件，扫描过程快且安全，它并不需要另外创建一个扫描线程</span><br><span class="line">* 支持自动去除旧的日志文件，可以控制已经产生日志文件的最大数量</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.imooc.com/article/21908" target="_blank" rel="noopener">https://www.imooc.com/article/21908</a><br><a href="https://cloud.tencent.com/developer/article/1154748" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1154748</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 集合框架</title>
      <link href="/2019/08/30/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/08/30/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h1><h2 id="集合框架图"><a href="#集合框架图" class="headerlink" title="集合框架图"></a>集合框架图</h2><p>Java集合是java提供的工具包，包含了常用的数据结构：集合、链表、队列、栈、数组、映射等。Java集合工具包位置是java.util.*。<br>Java集合主要可以划分为4个部分：List列表、Set集合、Map映射、工具类(Iterator迭代器、Enumeration枚举类、Arrays和Collections)。<br>Java集合工具包框架图(如下)：</p><p><img src="/images/java-collection.jpg" alt></p><p>基本集合实现类都不是线程安全的，比如：ArrayList, LinkedList, HashMap, HashSet, TreeMap, TreeSet等等。除了Vector和HashTable方法被synchronized修饰，是线程安全的，但性能低。</p><h2 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h2><h3 id="同步封装器"><a href="#同步封装器" class="headerlink" title="同步封装器"></a>同步封装器</h3><p>Java集合框架提供了工厂方法创建线程安全的集合，接口一致，实现上用集合的本身作为锁的对象在方法上添加synchronized，实现性能低。<br>使用iterator来遍历线程安全的集合对象的时候，还是需要添加synchronized字段来确保线程安全。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; safeList = Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br><span class="line">Map&lt;Integer, String&gt; safeMap = Collections.synchronizedMap(unsafeMap);</span><br></pre></td></tr></table></figure><h3 id="并发集合-1"><a href="#并发集合-1" class="headerlink" title="并发集合"></a>并发集合</h3><p>J.U.C并发包，即java.util.concurrent包，是JDK的核心工具包，是JDK1.5之后，由 Doug Lea实现并引入，其中包含并发集合框架。</p><p>整个java.util.concurrent包，按照功能可以大致划分如下：</p><p>juc-locks 锁框架<br>juc-atomic 原子类框架<br>juc-sync 同步器框架<br>juc-collections 集合框架<br>juc-executors 执行器框架</p><h4 id="Synchronized集合"><a href="#Synchronized集合" class="headerlink" title="Synchronized集合"></a>Synchronized集合</h4><p>集合类：HashTable<br>通过synchronized来保证线程安全的；即，多线程通过同一个“对象的同步锁”来实现并发控制。Hashtable在线程竞争激烈时，效率比较低。</p><h4 id="CopyOnWrite集合"><a href="#CopyOnWrite集合" class="headerlink" title="CopyOnWrite集合"></a>CopyOnWrite集合</h4><p>集合类：CopyOnWriteArrayList 和 CopyOnWriteArraySet；适用场景：读的操作远远大于写操作的情景下。</p><h5 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h5><p>往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。读时不需加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数。<br><strong>ReentrantLock锁+volatile</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class CopyOnWriteArrayList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;    </span><br><span class="line">    //ReentrantLock锁，没有使用Synchronized</span><br><span class="line">    transient final ReentrantLock lock = new ReentrantLock();    </span><br><span class="line">    //集合底层数据结构：数组（volatile修饰共享可见）</span><br><span class="line">    private volatile transient Object[] array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h5><p>CopyOnWriteArraySet包含CopyOnWriteArrayList对象，是通过CopyOnWriteArrayList实现的。</p><h4 id="CAS集合"><a href="#CAS集合" class="headerlink" title="CAS集合"></a>CAS集合</h4><p>集合类：ConcurrentLinkedQueue 和 ConcurrentSkipListMap.</p><h5 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h5><p>ConcurrentLinkedQueue通过volatile来实现多线程对竞争资源的互斥访问的。ConcurrentLinkedQueue的链表Node中的next的类型是volatile，而且链表数据item的类型也是volatile。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile Node&lt;E&gt; head;</span><br><span class="line">private transient volatile Node&lt;E&gt; tail;</span><br></pre></td></tr></table></figure><h5 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap（Entry数组+链表）：线程不安全</span><br><span class="line">HashTable （Entry数组+链表）: synchronized关键字修饰方法，线程同步</span><br><span class="line">LinkedHashMap（Entry数组+链表+双向链表）:保持插入顺序</span><br><span class="line">TreeMap（红黑树）：保持key排序</span><br></pre></td></tr></table></figure><p>结构<br><img src="/images/ConcurrentSkipListMap.jpg" alt></p><p>ConcurrentSkipListMap是线程安全的有序（实现了SortedMap接口，提供了一些根据键范围进行查找的功能；实现了NavigableMap接口，提供了指定Key返回最接近项、按升序/降序返回所有键的视图）的哈希表，适用于高并发的场景。<br>在非多线程的情况下，应当尽量使用TreeMap(红黑树实现)。此外对于并发性相对较低的并行程序可以使用Collections.synchronizedSortedMap将TreeMap进行包装，也可以提供较好的效率。对于高并发程序，应当使用ConcurrentSkipListMap(跳表实现)，能够提供更高的并发度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Main insertion method.  Adds element if not present, or</span><br><span class="line">    * replaces value if present and onlyIfAbsent is false.</span><br><span class="line">    * @param key the key</span><br><span class="line">    * @param value the value that must be associated with key</span><br><span class="line">    * @param onlyIfAbsent if should not insert if already present</span><br><span class="line">    * @return the old value, or null if newly inserted</span><br><span class="line">    */</span><br><span class="line">   private V doPut(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">       Node&lt;K,V&gt; z;             // added node</span><br><span class="line">       if (key == null)</span><br><span class="line">           throw new NullPointerException();</span><br><span class="line">       Comparator&lt;? super K&gt; cmp = comparator;</span><br><span class="line">       outer: for (;;) &#123;</span><br><span class="line">           for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">               if (n != null) &#123;</span><br><span class="line">                   Object v; int c;</span><br><span class="line">                   Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                   if (n != b.next)               // inconsistent read</span><br><span class="line">                       break;</span><br><span class="line">                   if ((v = n.value) == null) &#123;   // n is deleted</span><br><span class="line">                       n.helpDelete(b, f);</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">                   if (b.value == null || v == n) // b is deleted</span><br><span class="line">                       break;</span><br><span class="line">                   if ((c = cpr(cmp, key, n.key)) &gt; 0) &#123;</span><br><span class="line">                       b = n;</span><br><span class="line">                       n = f;</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">                   if (c == 0) &#123;</span><br><span class="line">                       if (onlyIfAbsent || n.casValue(v, value)) &#123;</span><br><span class="line">                           @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</span><br><span class="line">                           return vv;</span><br><span class="line">                       &#125;</span><br><span class="line">                       break; // restart if lost race to replace value</span><br><span class="line">                   &#125;</span><br><span class="line">                   // else c &lt; 0; fall through</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               z = new Node&lt;K,V&gt;(key, value, n);</span><br><span class="line">               if (!b.casNext(n, z))</span><br><span class="line">                   break;         // restart if lost race to append to b</span><br><span class="line">               break outer;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       int rnd = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">       if ((rnd &amp; 0x80000001) == 0) &#123; // test highest and lowest bits</span><br><span class="line">           int level = 1, max;</span><br><span class="line">           while (((rnd &gt;&gt;&gt;= 1) &amp; 1) != 0)</span><br><span class="line">               ++level;</span><br><span class="line">           Index&lt;K,V&gt; idx = null;</span><br><span class="line">           HeadIndex&lt;K,V&gt; h = head;</span><br><span class="line">           if (level &lt;= (max = h.level)) &#123;</span><br><span class="line">               for (int i = 1; i &lt;= level; ++i)</span><br><span class="line">                   idx = new Index&lt;K,V&gt;(z, idx, null);</span><br><span class="line">           &#125;</span><br><span class="line">           else &#123; // try to grow by one level</span><br><span class="line">               level = max + 1; // hold in array and later pick the one to use</span><br><span class="line">               @SuppressWarnings(&quot;unchecked&quot;)Index&lt;K,V&gt;[] idxs =</span><br><span class="line">                   (Index&lt;K,V&gt;[])new Index&lt;?,?&gt;[level+1];</span><br><span class="line">               for (int i = 1; i &lt;= level; ++i)</span><br><span class="line">                   idxs[i] = idx = new Index&lt;K,V&gt;(z, idx, null);</span><br><span class="line">               for (;;) &#123;</span><br><span class="line">                   h = head;</span><br><span class="line">                   int oldLevel = h.level;</span><br><span class="line">                   if (level &lt;= oldLevel) // lost race to add level</span><br><span class="line">                       break;</span><br><span class="line">                   HeadIndex&lt;K,V&gt; newh = h;</span><br><span class="line">                   Node&lt;K,V&gt; oldbase = h.node;</span><br><span class="line">                   for (int j = oldLevel+1; j &lt;= level; ++j)</span><br><span class="line">                       newh = new HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);</span><br><span class="line">                   if (casHead(h, newh)) &#123;</span><br><span class="line">                       h = newh;</span><br><span class="line">                       idx = idxs[level = oldLevel];</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           // find insertion points and splice in</span><br><span class="line">           splice: for (int insertionLevel = level;;) &#123;</span><br><span class="line">               int j = h.level;</span><br><span class="line">               for (Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) &#123;</span><br><span class="line">                   if (q == null || t == null)</span><br><span class="line">                       break splice;</span><br><span class="line">                   if (r != null) &#123;</span><br><span class="line">                       Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                       // compare before deletion check avoids needing recheck</span><br><span class="line">                       int c = cpr(cmp, key, n.key);</span><br><span class="line">                       if (n.value == null) &#123;</span><br><span class="line">                           if (!q.unlink(r))</span><br><span class="line">                               break;</span><br><span class="line">                           r = q.right;</span><br><span class="line">                           continue;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (c &gt; 0) &#123;</span><br><span class="line">                           q = r;</span><br><span class="line">                           r = r.right;</span><br><span class="line">                           continue;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   if (j == insertionLevel) &#123;</span><br><span class="line">                       if (!q.link(r, t))</span><br><span class="line">                           break; // restart</span><br><span class="line">                       if (t.node.value == null) &#123;</span><br><span class="line">                           findNode(key);</span><br><span class="line">                           break splice;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (--insertionLevel == 0)</span><br><span class="line">                           break splice;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   if (--j &gt;= insertionLevel &amp;&amp; j &lt; level)</span><br><span class="line">                       t = t.down;</span><br><span class="line">                   q = q.down;</span><br><span class="line">                   r = q.right;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Returns a base-level node with key strictly less than given key,</span><br><span class="line">    * or the base-level header if there is no such node.  Also</span><br><span class="line">    * unlinks indexes to deleted nodes found along the way.  Callers</span><br><span class="line">    * rely on this side-effect of clearing indices to deleted nodes.</span><br><span class="line">    * @param key the key</span><br><span class="line">    * @return a predecessor of key</span><br><span class="line">    */</span><br><span class="line">   private Node&lt;K,V&gt; findPredecessor(Object key, Comparator&lt;? super K&gt; cmp) &#123;</span><br><span class="line">       if (key == null)</span><br><span class="line">           throw new NullPointerException(); // don&apos;t postpone errors</span><br><span class="line">       for (;;) &#123;</span><br><span class="line">           for (Index&lt;K,V&gt; q = head, r = q.right, d;;) &#123;</span><br><span class="line">               if (r != null) &#123;</span><br><span class="line">                   Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                   K k = n.key;</span><br><span class="line">                   if (n.value == null) &#123;</span><br><span class="line">                       if (!q.unlink(r))</span><br><span class="line">                           break;           // restart</span><br><span class="line">                       r = q.right;         // reread r</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">                   if (cpr(cmp, key, k) &gt; 0) &#123;</span><br><span class="line">                       q = r;</span><br><span class="line">                       r = r.right;</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if ((d = q.down) == null)</span><br><span class="line">                   return q.node;</span><br><span class="line">               q = d;</span><br><span class="line">               r = d.right;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="对象锁（java-util-concurrent-lock-Lock）"><a href="#对象锁（java-util-concurrent-lock-Lock）" class="headerlink" title="对象锁（java.util.concurrent.lock.Lock）"></a>对象锁（java.util.concurrent.lock.Lock）</h4><p>这种锁和经典锁一样具有基本的功能，但还可以再特殊的情况下获取：如果当前没有被锁、超时、线程没有被打断。<br>不同于synchronization的代码,当方法在执行，Lock锁一直会被持有，直到调用unlock方法。有些实现通过这种机制把集合分为好几个部分来提供并发性能。比如：LinkedBlockingQueue，在队列的开后和结尾，所以在添加和删除的时候可以同时进行。<br>其他使用了这种机制的集合有：ConcurrentHashMap 和绝多数实现了BlockingQueue的实现类<br>同样的这一类的集合也具有不连贯的iterators，也不会抛出ConcurrentModificationException异常。</p><h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><p>ConcurrentHashMap是线程安全的哈希表，它是通过“锁分段”来保证线程安全的。ConcurrentHashMap将哈希表分成许多片段(Segment)，每一个片段除了保存哈希表之外，本质上也是一个“可重入的互斥锁”(ReentrantLock)。多线程对同一个片段的访问，是互斥的；但是，对于不同片段的访问，却是可以同步进行的。</p><p><img src="/images/ConcurrentHashMap.jpg" alt></p><h2 id="集合序列化"><a href="#集合序列化" class="headerlink" title="集合序列化"></a>集合序列化</h2><p>HashMap和ArrayList等实现时，以transient修饰数组。<br>自定义了序列化和反序列化的方法:<br>1.HashMap把当前buckets数量，size和里面的k,v对一一给写到了对象输出流里面，然后在反序列化的时候，再从流里面一一的解析出来，然后又重新恢复出了HashMap的整个数据结构。<br>2.ArrayList里面也是把其size和里面不为null的数据给写到流里面，然后在反序列化的时候重新使用数据把数据结构恢复出来。<br>原因：<br>HashMap:不同的jvm虚拟机对于同一个key产生的hashCode可能是不一样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public native int hashCode();</span><br></pre></td></tr></table></figure><p>ArrayList:缩短扩容数组长度</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.codejava.net/java-core/collections/understanding-collections-and-thread-safety-in-java" target="_blank" rel="noopener">https://www.codejava.net/java-core/collections/understanding-collections-and-thread-safety-in-java</a><br><a href="https://www.cnblogs.com/java-zzl/p/9767255.html" target="_blank" rel="noopener">https://www.cnblogs.com/java-zzl/p/9767255.html</a><br><a href="https://www.cnblogs.com/skywang12345/p/3498537.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3498537.html</a><br><a href="https://my.oschina.net/u/1027043/blog/1627441" target="_blank" rel="noopener">https://my.oschina.net/u/1027043/blog/1627441</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java 集合框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 日志框架</title>
      <link href="/2019/08/29/Java-%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/08/29/Java-%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-日志框架"><a href="#Java-日志框架" class="headerlink" title="Java 日志框架"></a>Java 日志框架</h1><h2 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h2><h3 id="JDK日志"><a href="#JDK日志" class="headerlink" title="JDK日志"></a>JDK日志</h3><p>JDK官方提供的一个记录日志的方式，直接在 JDK 中就可以使用。但 JDKLog 功能比较太过于简单，不支持占位符显示，拓展性比较差.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line">/****</span><br><span class="line"> ** JDKLog Demo</span><br><span class="line"> **/</span><br><span class="line">public class JDKLog</span><br><span class="line">&#123;</span><br><span class="line">    public static void main( String[] args )</span><br><span class="line">    &#123;</span><br><span class="line">        Logger logger = Logger.getLogger(&quot;JDKLog&quot;);</span><br><span class="line">        logger.info(&quot;Hello World.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Log4J"><a href="#Log4J" class="headerlink" title="Log4J"></a>Log4J</h3><p>Log4J 有 1.X 版本和 2.X 版本，现在官方推荐使用 2.X 版本，2.X 版本在架构上进行了一些升级，比方支持參数API、支持异步appender、插件式架构等，配置文件也发生了一些变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">官方配置说明文档</span><br><span class="line">http://logging.apache.org/log4j/1.x/manual/configuration.html</span><br><span class="line">http://logging.apache.org/log4j/2.x/manual/configuration.html</span><br></pre></td></tr></table></figure><p>使用 Log4J 框架首先需要引入依赖的包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Log4J --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.6.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.6.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>增加配置文件 log4j2.xml 放在 resource 目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;Configuration status=&quot;WARN&quot;&gt;</span><br><span class="line">    &lt;Appenders&gt;</span><br><span class="line">        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;</span><br><span class="line">            &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;</span><br><span class="line">        &lt;/Console&gt;</span><br><span class="line">    &lt;/Appenders&gt;</span><br><span class="line">    &lt;Loggers&gt;</span><br><span class="line">        &lt;Root level=&quot;info&quot;&gt;</span><br><span class="line">            &lt;AppenderRef ref=&quot;Console&quot;/&gt;</span><br><span class="line">        &lt;/Root&gt;</span><br><span class="line">    &lt;/Loggers&gt;</span><br><span class="line">&lt;/Configuration&gt;</span><br><span class="line">其中&lt;Root&gt;节点的 level 属性表示输出的最低级别。</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.logging.log4j.LogManager;</span><br><span class="line">import org.apache.logging.log4j.Logger;</span><br><span class="line"></span><br><span class="line">/****</span><br><span class="line"> ** Log4J Demo</span><br><span class="line"> **/</span><br><span class="line">public class Log4jLog &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Logger logger = LogManager.getLogger(Log4jLog.class);</span><br><span class="line">        logger.debug(&quot;Debug Level&quot;);</span><br><span class="line">        logger.info(&quot;Info Level&quot;);</span><br><span class="line">        logger.warn(&quot;Warn Level&quot;);</span><br><span class="line">        logger.error(&quot;Error Level&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LogBack"><a href="#LogBack" class="headerlink" title="LogBack"></a>LogBack</h3><p>LogBack 其实可以说是 Log4J 的进化版，因为它们两个都是同一个人（Ceki Gülcü）设计的开源日志组件。LogBack 除了具备 Log4j 的所有优点之外，还解决了 Log4J 不能使用占位符的问题。</p><p>引入依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- LogBack --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.1.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置 logback.xml 配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;</span><br><span class="line">            &lt;Pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/Pattern&gt;</span><br><span class="line">        &lt;/layout&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">    &lt;logger name=&quot;com.chanshuyi&quot; level=&quot;TRACE&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;root level=&quot;debug&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>LogBack 的日志级别区分可以细分到类或者包，这样就可以使日志记录变得更加灵活。之后在类文件中引入Logger类，并进行日志记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">/****</span><br><span class="line"> ** LogBack Demo</span><br><span class="line"> **/</span><br><span class="line">public class LogBack &#123;</span><br><span class="line">    static final Logger logger = LoggerFactory.getLogger(LogBack.class);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        logger.trace(&quot;Trace Level.&quot;);</span><br><span class="line">        logger.debug(&quot;Debug Level.&quot;);</span><br><span class="line">        logger.info(&quot;Info Level.&quot;);</span><br><span class="line">        logger.warn(&quot;Warn Level.&quot;);</span><br><span class="line">        logger.error(&quot;Error Level.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LogBack 解决了 Log4J 不能使用占位符的问题，这使得阅读日志代码非常方便。除此之外，LogBack 比 Log4J 有更快的运行速度，更好的内部实现。并且 LogBack 内部集成了 SLF4J 可以更原生地实现一些日志记录的实现。</p><h3 id="门面模式：Facade模式"><a href="#门面模式：Facade模式" class="headerlink" title="门面模式：Facade模式"></a>门面模式：Facade模式</h3><p>现在Java应用日志收集都是采用日志框架(slf4j、apache commons logging)+日志系统（log4j、log4j2、LogBack、JUL等）的方式</p><p>日志框架：提供日志调用的接口，实际的日志输出托付给日志系统实现。</p><p>日志系统：负责输出日志，比如<br>    Log4j内部把日志系统抽象封装成Logger 、appender 、pattern 等实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">        Appenders：也被称为Handlers。负责将日志事件记录到目标位置。在将日志事件输出之前，Appenders使用Layouts来对事件进行格式化处理。</span><br><span class="line">        Layouts：也被称为Formatters，它负责对日志事件中的数据进行转换和格式化。Layouts决定了数据在一条日志记录中的终于形式。</span><br><span class="line">        Loggers：Logger负责捕捉事件并将其发送给合适的Appender。</span><br><span class="line"> ```  </span><br><span class="line">#### 实现机制</span><br><span class="line"></span><br><span class="line">##### Commons Logging实现机制</span><br><span class="line">Commons Logging是通过动态查找机制，在程序运行时，使用自己的ClassLoader寻找和载入本地具体的实现。</span><br><span class="line"></span><br><span class="line">##### Slf4j实现机制</span><br><span class="line">Slf4j在编译期间，静态绑定本地的Log库，因此可以在Osgi中正常使用。它是通过查找类路径下org.slf4j.impl.StaticLoggerBinder，然后在StaticLoggerBinder中进行绑定。 </span><br><span class="line"></span><br><span class="line">#### SLF4J：适配器</span><br><span class="line"></span><br><span class="line">SLF4J（Simple Logging Facade for Java，即Java简单日志记录接口集）是一个日志的接口规范，它对用户提供了统一的日志接口，屏蔽了不同日志组件的差异。</span><br><span class="line">* 使用了Facade设计模式，Slf4j本身只提供了一个slf4j-api-version.jar包，这个jar中主要是日志的抽象接口，jar中本身并没有对抽象出来的接口做实现。</span><br><span class="line">* 对于不同的日志实现方案(例如Logback，Log4j...)，封装出不同的桥接组件(例如logback-classic-version.jar，slf4j-log4j12-version.jar)</span><br><span class="line">![](images/slf4j-bind.png)</span><br><span class="line"></span><br><span class="line">##### SLF4J+JDKLog</span><br><span class="line">SLF4J + JDKLog 需要在 Maven 中导入以下依赖包：</span><br></pre></td></tr></table></figure><dependency>  <groupid>org.slf4j</groupid>  <artifactid>slf4j-api</artifactid>  <version>1.7.21</version></dependency><dependency>  <groupid>org.slf4j</groupid>  <artifactid>slf4j-jdk14</artifactid>  <version>1.7.21</version></dependency><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试类：</span><br></pre></td></tr></table></figure><p>import org.slf4j.Logger;<br>import org.slf4j.LoggerFactory;</p><p>/****<br> ** SLF4J + JDKLog<br> **/<br>public class Slf4jJDKLog {<br>    final static Logger logger = LoggerFactory.getLogger(Slf4jJDKLog.class);<br>    public static void main(String[] args) {<br>        logger.trace(“Trace Level.”);<br>        logger.info(“Info Level.”);<br>        logger.warn(“Warn Level.”);<br>        logger.error(“Error Level.”);<br>    }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">##### SLF4J+LOG4J</span><br><span class="line">需要依赖的 Jar 包：slf4j-api.jar、slf4j-412.jar、log4j.jar，导入Maven依赖：</span><br></pre></td></tr></table></figure><!-- 2.SLF4J + Log4J --><dependency>  <groupid>org.slf4j</groupid>  <artifactid>slf4j-api</artifactid>  <version>1.7.21</version></dependency><dependency>  <groupid>org.slf4j</groupid>  <artifactid>slf4j-log4j12</artifactid>  <version>1.7.21</version></dependency><dependency>  <groupid>log4j</groupid>  <artifactid>log4j</artifactid>  <version>1.2.17</version></dependency><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">配置 log4j.xml 文件：</span><br></pre></td></tr></table></figure><?xml version="1.0" encoding="UTF-8"?><!DOCTYPE log4j:configuration SYSTEM "log4j.dtd"><p>&lt;log4j:configuration xmlns:log4j=’<a href="http://jakarta.apache.org/log4j/&#39;" target="_blank" rel="noopener">http://jakarta.apache.org/log4j/&#39;</a> &gt;</p><pre><code>&lt;appender name=&quot;console&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt;    &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;        &lt;param name=&quot;ConversionPattern&quot;               value=&quot;[%d{dd HH:mm:ss,SSS\} %-5p] [%t] %c{2\} - %m%n&quot; /&gt;    &lt;/layout&gt;    &lt;!--过滤器设置输出的级别--&gt;    &lt;filter class=&quot;org.apache.log4j.varia.LevelRangeFilter&quot;&gt;        &lt;param name=&quot;levelMin&quot; value=&quot;debug&quot; /&gt;        &lt;param name=&quot;levelMax&quot; value=&quot;error&quot; /&gt;        &lt;param name=&quot;AcceptOnMatch&quot; value=&quot;true&quot; /&gt;    &lt;/filter&gt;&lt;/appender&gt;&lt;!-- 根logger的设置--&gt;&lt;root&gt;    &lt;priority value =&quot;debug&quot;/&gt;    &lt;appender-ref ref=&quot;console&quot;/&gt;&lt;/root&gt;</code></pre><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">##### SLF4J+LogBack</span><br><span class="line">导入依赖：</span><br></pre></td></tr></table></figure><dependency>  <groupid>org.slf4j</groupid>  <artifactid>slf4j-api</artifactid>  <version>1.7.21</version></dependency><dependency>  <groupid>ch.qos.logback</groupid>  <artifactid>logback-classic</artifactid>  <version>1.1.7</version></dependency><dependency>  <groupid>ch.qos.logback</groupid>  <artifactid>logback-core</artifactid>  <version>1.1.7</version></dependency><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">配置 logback.xml 文件：</span><br></pre></td></tr></table></figure><?xml version="1.0" encoding="UTF-8"?><configuration>    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">        <layout class="ch.qos.logback.classic.PatternLayout">            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>        </layout>    </appender><pre><code>&lt;root level=&quot;warn&quot;&gt;    &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;&lt;/root&gt;</code></pre></configuration>```<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/gavanwanggw/p/7305218.html" target="_blank" rel="noopener">https://www.cnblogs.com/gavanwanggw/p/7305218.html</a><br><a href="https://www.cnblogs.com/chenhongliang/p/5312517.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenhongliang/p/5312517.html</a><br><a href="http://www.imooc.com/article/21543" target="_blank" rel="noopener">http://www.imooc.com/article/21543</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP</title>
      <link href="/2019/08/28/Spring-AOP/"/>
      <url>/2019/08/28/Spring-AOP/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><h2 id="AOP面向切面"><a href="#AOP面向切面" class="headerlink" title="AOP面向切面"></a>AOP面向切面</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">实现</span><br><span class="line">1.静态代理：接口</span><br><span class="line">2.JDK动态代理：反射机制</span><br><span class="line">3.CGLib(Code Generation Library):采用底层字节码技术，创建子类，织入横切逻辑。</span><br></pre></td></tr></table></figure><p>Spring </p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV 学习</title>
      <link href="/2019/08/19/OpenCV-%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/08/19/OpenCV-%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QRCode学习</title>
      <link href="/2019/08/15/QRCode%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/08/15/QRCode%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="QRCode-学习"><a href="#QRCode-学习" class="headerlink" title="QRCode   学习"></a>QRCode   学习</h1><p>二维条形码是用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的；在代码编制上巧妙地利用构成计算机内部逻辑基础的“0”、“1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图象输入设备或光电扫描设备自动识读以实现信息自动处理：它具有条码技术的一些共性：每种码制有其特定的字符集；每个字符占有一定的宽度；具有一定的校验功能等。同时还具有对不同行的信息自动识别功能、及处理图形旋转变化等特点。二维条形码能够在横向和纵向两个方位同时表达信息，因此能在很小的面积内表达大量的信息。</p><h2 id="QRCode-类型"><a href="#QRCode-类型" class="headerlink" title="QRCode 类型"></a>QRCode 类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">堆叠式二维条形码(2D Stacked Code)：堆叠式二维条形码是一种多层符号(Multi-Row Symbology)，通常是将一维条形码的高度截短再层叠起来表示资料。</span><br><span class="line">矩阵式二维条形码(2D Matrix Code)：矩阵式二条形码是一种由中心点到与中心点固定距离的多边形单元所组成的图形，用来表示资料及其它与符号相关功能。</span><br><span class="line">资料字元(Data Character)：用于表示特定资料的ASCII字元集的一个字母、数字或特殊符号等字元。</span><br><span class="line">符号字元(Symbol Character)：依条形码符号规则定义来表示资料的线条、空白组合形式。资料字元与符号字元间不一定是一对一的关系。一般情况下，每个符号字元分配一个唯一的值。</span><br><span class="line">代码集(Code Set)：代码集是指将资料字元转化为符号字元值的方法。</span><br><span class="line">字码(Codeword)：字码是指符号字元的值，为原始资料转换为符号字元过程的一个中间值，一种条形码的字码数决定了该类条形码所有符号字元的数量。</span><br><span class="line">字元自我检查(Character Self-Checking)：字元自我检查是指在一个符号字元中出现单一的印刷错误时，扫瞄器不会将该符号字元解码成其它符号字元的特性。</span><br><span class="line">错误纠正字元(Error Correction Character)：用于错误侦测和错误纠正的符号字元，这些字元是由其它符号字元计算而得，二维条形码一般有多个错误纠正字元用于错误侦测以及错误纠正。有些线性扫瞄器有一个错误纠正字元用于侦测错误。</span><br><span class="line">E错误纠正(Erasure Correction)：E错误是指在已知位置上因图像对比度不够，或有大污点等原因造成该位置符号字元无法辨识，因此又称为拒读错误。通过错误纠正字元对E错误的恢复称为E错误纠正。对于每个E错误的纠正仅需一个错误纠正字元。</span><br><span class="line">T错误纠正(Error Correction)：T错误是指因某种原因将一个符号字元识读为其它符号字元的错误，因此又称为替代错误。T错误的位置以及该位置的正确值都是未知的，因此对每个T错误的纠正需要两个错误纠正字元，一个用于找出位置，另一个用于纠正错误。</span><br><span class="line">错误侦测(Error Detection)：一般是保留一些错误纠正字元用于错误侦测，这些字元被称为侦测字元，用以侦测出符号中不超出错误纠正容量的错误数量，从而保证符号不被读错。此外，也可利用软体透过侦测无效错误纠正的计算结果提供错误侦测功能。若仅为E错误纠正则不提供错误侦测功能。</span><br></pre></td></tr></table></figure><h3 id="堆叠式-行排式"><a href="#堆叠式-行排式" class="headerlink" title="堆叠式/行排式"></a>堆叠式/行排式</h3><p>堆叠式/行排式二维条码又称堆积式二维条码或层排式二维条码），其编码原理是建立在一维条码基础之上，按需要堆积成二行或多行。它在编码设计、校验原理、识读方式等方面继承了一维条码的一些特点，识读设备与条码印刷与一维条码技术兼容。但由于行数的增加，需要对行进行判定，其译码算法与软件也不完全相同于一维条码。有代表性的行排式二维条码有：Code 16K、Code 49、PDF417等。</p><h3 id="矩阵式"><a href="#矩阵式" class="headerlink" title="矩阵式"></a>矩阵式</h3><p>矩阵式二维条码（又称棋盘式二维条码）它是在一个矩形空间通过黑、白像素在矩阵中的不同分布进行编码。在矩阵相应元素位置上，用点（方点、圆点或其他形状）的出现表示二进制“1”，点的不出现表示二进制的“0”，点的排列组合确定了矩阵式二维条码所代表的意义。矩阵式二维条码是建立在计算机图像处理技术、组合编码原理等基础上的一种新型图形符号自动识读处理码制。具有代表性的矩阵式二维条码有：Code One、Maxi Code、QR Code、 Data Matrix等。</p><h2 id="QR-Code码"><a href="#QR-Code码" class="headerlink" title="QR Code码"></a>QR Code码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、符号规格从版本1（21×21模块）到版本40（177×177 模块），每提高一个版本，每边增加4个模块。</span><br><span class="line">2、数据类型与容量（参照最大规格符号版本40-L级）：</span><br><span class="line">数字数据：7,089个字符</span><br><span class="line">字母数据: 4,296个字符</span><br><span class="line">8位字节数据: 2,953个字符</span><br><span class="line">汉字数据：1,817个字符</span><br><span class="line">3、数据表示方法：</span><br><span class="line">深色模块表示二进制&quot;1&quot;，浅色模块表示二进制&quot;0&quot;。</span><br><span class="line">4、纠错能力：</span><br><span class="line">L级：约可纠错7%的数据码字</span><br><span class="line">M级：约可纠错15%的数据码字</span><br><span class="line">Q级：约可纠错25%的数据码字</span><br><span class="line">H级：约可纠错30%的数据码字</span><br><span class="line">5、结构链接（可选）</span><br><span class="line">可用1-16个QR Code码符号表示一组信息。每一符号表示100个字符的信息。</span><br></pre></td></tr></table></figure><p><img src="/images/qrcode.png" alt></p><h3 id="QR-Code码生成"><a href="#QR-Code码生成" class="headerlink" title="QR Code码生成"></a>QR Code码生成</h3><h4 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h4><p>确定编码的字符类型，按相应的字符集转换成符号字符； 选择纠错等级，在规格一定的条件下，纠错等级越高其真实数据的容量越小。</p><h4 id="数据编码"><a href="#数据编码" class="headerlink" title="数据编码"></a>数据编码</h4><p>将数据字符转换为位流，每8位一个码字，整体构成一个数据的码字序列。其实知道这个数据码字序列就知道了二维码的数据内容。<br>以数据01234567编码为例</p><p>1）分组：012 345 67</p><p>2）转成二进制：012→0000001100      345→0101011001     67 →1000011</p><p>3）转成序列：0000001100 0101011001 1000011</p><p>4）字符数 转成二进制：8→0000001000</p><p>5）加入模式指示符 0001：0001 0000001000 0000001100 0101011001 1000011</p><h4 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h4><p>按需要将上面的码字序列分块，并根据纠错等级和分块的码字，产生纠错码字，并把纠错码字加入到数据码字序列后面，成为一个新的序列。在二维码规格和纠错等级确定的情况下，其实它所能容纳的码字总数和纠错码字数也就确定了，比如：版本10，纠错等级是H时，总共能容纳346个码字，其中224个纠错码字。就是说二维码区域中大约1/3的码字是冗余的。对于这224个纠错码字，它能够纠正112个替代错误（如黑白颠倒）或者224个句读错误（无法读到或者无法译码），这样纠错容量为：112/346=32.4%</p><h4 id="构造最终数据信息"><a href="#构造最终数据信息" class="headerlink" title="构造最终数据信息"></a>构造最终数据信息</h4><p>在规格确定的条件下，将上面产生的序列按次序放如分块中按规定把数据分块，然后对每一块进行计算，得出相应的纠错码字区块，把纠错码字区块 按顺序构成一个序列，添加到原先的数据码字序列后面。如：D1, D12, D23, D35, D2, D13, D24, D36, … D11, D22, D33, D45, D34, D46, E1, E23,E45, E67, E2, E24, E46, E68，…</p><h4 id="构造矩阵"><a href="#构造矩阵" class="headerlink" title="构造矩阵"></a>构造矩阵</h4><p><img src="/images/qrcode2.png" alt></p><ul><li><p>位置探测图形、位置探测图形分隔符、定位图形：用于对二维码的定位，对每个QR码来说，位置都是固定存在的，只是大小规格会有所差异；</p></li><li><p>校正图形：规格确定，校正图形的数量和位置也就确定了；</p></li><li><p>格式信息：表示改二维码的纠错级别，分为L、M、Q、H；</p></li><li><p>版本信息：即二维码的规格，QR码符号共有40种规格的矩阵（一般为黑白色），从21×21（版本1），到177×177（版本40），每一版本符号比前一版本 每边增加4个模块。</p></li><li><p>数据和纠错码字：实际保存的二维码信息，和纠错码字（用于修正二维码损坏带来的错误）。</p></li></ul><p>将探测图形、分隔符、定位图形、校正图形和码字模块放入矩阵中，并把上面的完整序列填充到相应规格的二维码矩阵的区域中。</p><p><img src="images/qrcode3.png" alt></p><h4 id="掩膜"><a href="#掩膜" class="headerlink" title="掩膜"></a>掩膜</h4><p>将掩摸图形用于符号的编码区域，使得二维码图形中的深色和浅色（黑色和白色）区域能够比率最优的分布。</p><h4 id="格式和版本信息"><a href="#格式和版本信息" class="headerlink" title="格式和版本信息"></a>格式和版本信息</h4><p>生成格式和版本信息放入相应区域内。版本7-40都包含了版本信息，没有版本信息的全为0。二维码上两个位置包含了版本信息，它们是冗余的。版本信息共18位，6X3的矩阵，其中6位时数据为，如版本号8，数据位的信息时 001000，后面的12位是纠错位。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://cli.im/" target="_blank" rel="noopener">https://cli.im/</a><br><a href="https://www.douban.com/group/topic/9147222/" target="_blank" rel="noopener">https://www.douban.com/group/topic/9147222/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> qrcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-存储引擎</title>
      <link href="/2019/08/01/Mysql-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2019/08/01/Mysql-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql存储引擎"><a href="#Mysql存储引擎" class="headerlink" title="Mysql存储引擎"></a>Mysql存储引擎</h1><p>MySQL插件式存储引擎体系结构在存储级别上提供了一致和简单的应用模型和API，应用程序编程人员和DBA可不再考虑所有的底层实施细节。</p><p><img src="images/mysql-pluggable-storage.png" alt></p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>从技术角度上看，在存储引擎的一些关键差别包括：</p><ul><li>并发性：某些应用程序比其他应用程序具有很多的颗粒级锁定要求（如行级锁定）。选择正确的锁定策略能够减少开销，并有助于整体性能的提升。它还包括对多种能力的支持，如多版本并发性控制或“快照”读取等。</li><li>事务支持：并非所有的应用程序都需要事务，但对的确需要事务的应用程序来说，有着定义良好的需求，如ACID兼容等。</li><li>引用完整性：通过DDDL定义的 外键，服务器需要强制保持关联数据库的引用完整性。</li><li>物理存储：它包括各种各样的事项，从表和索引的总的页大小，到存储数据所需的格式，到物理磁盘。</li><li>索引支持：不同的应用程序倾向于采用不同的索引策略，每种存储引擎通常有自己的编制索引方法，但某些索引方法（如B-tree索引）对几乎所有的存储引擎来说是共同的。</li><li>内存高速缓冲：与其他应用程序相比，不同的应用程序对某些内存高速缓冲策略的响应更好，因此，尽管某些内存高速缓冲对所有存储引擎来说是共同的（如用于用户连接的高速缓冲，MySQL的高速查询高速缓冲等），其他高速缓冲策略仅当使用特殊的存储引擎时才唯一定义。</li><li>性能帮助：包括针对并行操作的多I/O线程，线程并发性，数据库检查点，成批插入处理等。</li><li>其他目标特性：可能包括对地理空间操作的支持，对特定数据处理操作的安全限制等。</li></ul><p><img src="images/pluggable-storage-choosing.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>参考</title>
      <link href="/2019/07/31/%E5%8F%82%E8%80%83/"/>
      <url>/2019/07/31/%E5%8F%82%E8%80%83/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://liuzhengyang.github.io/" target="_blank" rel="noopener">https://liuzhengyang.github.io/</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 概述</title>
      <link href="/2019/07/31/Mysql-%E6%A6%82%E8%BF%B0/"/>
      <url>/2019/07/31/Mysql-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql-概述"><a href="#Mysql-概述" class="headerlink" title="Mysql 概述"></a>Mysql 概述</h1><p>MySQL从概念上可以分为四层，顶层是接入层，不同语言的客户端通过mysql的协议与mysql服务器进行连接通信，接入层进行权限验证、连接池管理、线程管理等。下面是mysql服务层，包括sql解析器、sql优化器、数据缓冲、缓存等。再下面是mysql中的存储引擎层，mysql中存储引擎是基于表的。最后是系统文件层，保存数据、索引、日志等。<br><img src="images/mysql.jpg" alt></p><h2 id="Mysql-特性"><a href="#Mysql-特性" class="headerlink" title="Mysql 特性"></a>Mysql 特性</h2><ul><li>使用C和C++编写</li><li>提供了事务性和非事务性存储引擎</li><li>使用了极快的“B树”磁盘表（MyISAM）和索引压缩</li><li>采用核心线程的完全多线程 如果有多个CPU，它能方便地使用这些CPU</li><li>极快的基于线程的内存分配系统。</li><li>通过使用优化的“单扫描多连接”，能实现极快的连接。</li><li>存储器中的哈希表用作临时表。</li><li>可伸缩性和限制<br>  1.处理大型数据库： 我们使用了MySQL服务器和含5千万条记录的数据库。我们还听说，有些用户将MySQL用于含60000个表和约50亿行的数据库。<br>  2.每个表可支持高达64条索引（在MySQL 4.1.2之前为32条）。每条索引可由1～16个列或列元素组成。最大索引宽度为1000字节（在MySQL 4.1.2之前为500）。索引可使用具备CHAR、VARCHAR、BLOB或TEXT列类型的列前缀。</li></ul><h2 id="Mysql-程序"><a href="#Mysql-程序" class="headerlink" title="Mysql 程序"></a>Mysql 程序</h2><h3 id="MYSQL服务器和服务器启动脚本："><a href="#MYSQL服务器和服务器启动脚本：" class="headerlink" title="MYSQL服务器和服务器启动脚本："></a>MYSQL服务器和服务器启动脚本：</h3><ul><li><p>mysqld是MySQL服务器</p></li><li><p>mysqld_safe、mysql.server和mysqld_multi是服务器启动脚本</p></li><li><p>mysql_install_db初始化数据目录和初始数据库</p><h3 id="访问服务器的客户程序："><a href="#访问服务器的客户程序：" class="headerlink" title="访问服务器的客户程序："></a>访问服务器的客户程序：</h3></li><li><p>mysql是一个命令行客户程序，用于交互式或以批处理模式执行SQL语句。</p></li><li><p>mysqladmin是用于管理功能的客户程序。</p></li><li><p>mysqlcheck执行表维护操作。</p></li><li><p>mysqldump和mysqlhotcopy负责数据库备份。</p></li><li><p>mysqlimport导入数据文件。 </p></li><li><p>mysqlshow显示信息数据库和表的相关信息。</p><h3 id="独立于服务器操作的工具程序："><a href="#独立于服务器操作的工具程序：" class="headerlink" title="独立于服务器操作的工具程序："></a>独立于服务器操作的工具程序：</h3></li><li><p>myisamchk执行表维护操作。</p></li><li><p>myisampack产生压缩、只读的表。</p></li><li><p>mysqlbinlog是处理二进制日志文件的实用工具。</p></li><li><p>perror显示错误代码的含义。</p></li></ul><h3 id="Mysql复制"><a href="#Mysql复制" class="headerlink" title="Mysql复制"></a>Mysql复制</h3><p>MySQL支持单向、异步复制，复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。</p><h4 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h4><p>每个从服务器从主服务器接收主服务器已经记录到其二进制日志的保存的更新，以便从服务器可以对其数据拷贝执行相同的更新。<br>将主服务器的数据拷贝到从服务器的一个途径是使用LOAD DATA FROM MASTER语句。请注意LOAD DATA FROM MASTER目前只在所有表使用MyISAM存储引擎的主服务器上工作。并且，该语句将获得全局读锁定，因此当表正复制到从服务器上时，不可能在主服务器上进行更新。当我们执行表的无锁热备份时，则不再需要全局读锁定。</p><p>MySQL使用3个线程来执行复制功能(其中1个在主服务器上，另两个在从服务器上。当发出START SLAVE时，从服务器创建一个I/O线程，以连接主服务器并让它发送记录在其二进制日志中的语句。主服务器创建一个线程将二进制日志中的内容发送到从服务器。该线程可以识别为主服务器上SHOW PROCESSLIST的输出中的Binlog Dump线程。从服务器I/O线程读取主服务器Binlog Dump线程发送的内容并将该数据拷贝到从服务器数据目录中的本地文件中，即中继日志。第3个线程是SQL线程，是从服务器创建用于读取中继日志并执行日志中包含的更新。</p><h4 id="复制操作"><a href="#复制操作" class="headerlink" title="复制操作"></a>复制操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; GRANT REPLICATION SLAVE ON *.* TO &apos;repl&apos;@&apos;%.mydomain.com&apos; IDENTIFIED BY &apos;slavepass&apos;;</span><br><span class="line">&gt; FLUSH TABLES WITH READ LOCK;</span><br><span class="line">&gt; SHOW MASTER STATUS;</span><br><span class="line">$ tar -cvf /tmp/mysql-snapshot.tar .#使用归档程序对主服务器上的数据目录中的数据库进行二进制备份</span><br><span class="line">&gt; UNLOCK TABLES;</span><br><span class="line"></span><br><span class="line">$ mysqldump --master-data</span><br><span class="line">&gt; mysqld --skip-slave-start</span><br><span class="line">&gt; mysql -u root -p &lt; dump_file.sql</span><br><span class="line">&gt; START SLAVE；</span><br></pre></td></tr></table></figure><p>my.cnf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server-id=1</span><br></pre></td></tr></table></figure><h3 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h3><ul><li>mysql簇<br><img src="images/cluster-components-1.png" alt></li><li>分区<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employees (</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    fname VARCHAR(30),</span><br><span class="line">    lname VARCHAR(30),</span><br><span class="line">    hired DATE NOT NULL DEFAULT &apos;1970-01-01&apos;,</span><br><span class="line">    separated DATE NOT NULL DEFAULT &apos;9999-12-31&apos;,</span><br><span class="line">    job_code INT NOT NULL,</span><br><span class="line">    store_id INT NOT NULL</span><br><span class="line">)</span><br><span class="line">PARTITION BY RANGE (store_id) (</span><br><span class="line">    PARTITION p0 VALUES LESS THAN (6),</span><br><span class="line">    PARTITION p1 VALUES LESS THAN (11),</span><br><span class="line">    PARTITION p2 VALUES LESS THAN (16),</span><br><span class="line">    PARTITION p3 VALUES LESS THAN (21)</span><br><span class="line">)；</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.mysqlzh.com/" target="_blank" rel="noopener">https://www.mysqlzh.com/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 优化（三）</title>
      <link href="/2019/07/31/Mysql-%E4%BC%98%E5%8C%96/"/>
      <url>/2019/07/31/Mysql-%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="mysql优化方向概述"><a href="#mysql优化方向概述" class="headerlink" title="mysql优化方向概述"></a>mysql优化方向概述</h2><p>mysql在开发中的优化主要有4个方向：<br>    1. 存储层：数据表存储引擎选取、字段类型选取、查询缓存、3范式、数据碎片维护<br>    2. 设计层：索引、分区、分表<br>    3. 架构层：分布式部署(集群)(主从复制、读写分离)<br>    4. sql语句层：锁的使用、慢查询的定位、limit分页优化<br>    5. 其他</p><h3 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h3><p>三种存储引擎特点</p><ul><li>Myisam：表锁，全文索引</li><li>Innodb：行(记录)锁，事务(回滚)，外键</li><li>Memory：内存存储引擎，速度快、数据容易丢失</li></ul><h4 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h4><p>(1) 存储格式</p><p>表结构存储于* .frm文件中。<br>默认所有表的数据/索引存储在同一个表空间文件中。<br>可以通过配置将不同表的数据/索引单独存储在*.ibd中，方便管理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t1(id int, name varchar(32))engine innodb charset utf8;</span><br><span class="line">mysql&gt; show variables like &apos;innodb_file_per_table%&apos;;</span><br><span class="line">mysql&gt; set global innodb_file_per_table=1;</span><br></pre></td></tr></table></figure><p>(2) 存储顺序: 主键顺序</p><p>数据按照主键顺序存储，写入顺序与存储顺序不同，因此速度比Myisam稍慢。</p><p>(3) 并发处理</p><p>擅长并发处理，支持行级锁和表级锁。</p><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p>(1) 存储格式<br>mysql5.5以下默认存储引擎。<br>结构、数据、索引分别存储于frm、MYD、MYI文件中，支持直接通过文件复制粘贴进行备份还原。<br>(2) 存储顺序: 插入顺序<br>写入速度快<br>(3) 并发处理<br>不如innodb，只支持表级锁<br>(4) 压缩性<br>对于不频繁发生变化的数据，可以进行压缩，压缩后只读，写操作需要先解压</p><h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><p>内存存储引擎，速度快、数据容易丢失，可以用作缓存。</p><h4 id="innodb-amp-myisam-的适用场"><a href="#innodb-amp-myisam-的适用场" class="headerlink" title="innodb &amp; myisam 的适用场"></a>innodb &amp; myisam 的适用场</h4><p>myisam：写入快，适合写入、读取操作多的系统，如微博。表锁，全文索引。</p><p>innodb：适合业务逻辑强、修改操作多的系统，如商城、办公系统。行(记录)锁，事务(回滚)，外键。</p><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>mysql服务器提供的用于缓存select语句结果的一种内部内存缓存系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;query_cache%&apos;;</span><br><span class="line"># query_cache_size: 缓存空间大小</span><br><span class="line"># query_cache_type: 是否开启缓存</span><br><span class="line"># 在 my.ini 中开启缓存，设置缓存空间为128M</span><br><span class="line">query_cache_type=1</span><br><span class="line">query_cache_size=134217728</span><br><span class="line"># 重启mysql</span><br></pre></td></tr></table></figure><h4 id="缓存失效"><a href="#缓存失效" class="headerlink" title="缓存失效"></a>缓存失效</h4><p>数据表的数据发生变化(数据修改)或结构改变(字段增删)，则会清空全部的缓存数据，即缓存失效。<br>sql语句中有变化表达式(时间、随机数等)，则不会使用缓存。<br>生成缓存的sql语句对”空格”、”大小写”敏感，相同结果的sql语句，由于空格、大小写问题就会分别生成多个缓存     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name, now() from t2 where id=1234; # 不使用缓存</span><br><span class="line">mysql&gt; select * from t2 order by rand() limit 5; # 不使用缓存</span><br><span class="line"></span><br><span class="line">mysql&gt; select sql_no_cache * from t2 where id=1234; #禁用缓存</span><br><span class="line"> </span><br><span class="line">mysql&gt; show status like &apos;Qcache%&apos;;#查看缓存空间的使用</span><br></pre></td></tr></table></figure><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>范式主要分为四类范式，在开发过程中没有特殊情况数据表尽量要设计为第三范式。</p><p>第一范式：<br>(1) 表属性(列)具有原子性(不可分割)<br>(2) 表属性(列)不能重复</p><p>第二范式：<br>表中不能存在完全相同的两条记录，通常通过设置主键来实现。</p><p>第三范式：<br>表中不能存在冗余数据，列数据不能通过推导得到。</p><p>反三范式：<br>有时出于性能考虑，有意违反三范式，适度冗余，提高查询效率，例如存储浏览量。</p><h3 id="数据碎片与维护"><a href="#数据碎片与维护" class="headerlink" title="数据碎片与维护"></a>数据碎片与维护</h3><p>长期数据操作过程中，索引和数据文件产生空洞碎片，会拖慢执行效率，需要修复，修复可以把数据文件重新整理，使之对齐。由于修复十分消耗资源，如果表的update、delete操作频繁，可以按周月修复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 方式1:</span><br><span class="line">mysql&gt; alter table engine innodb;</span><br><span class="line"># 方式2:</span><br><span class="line">mysql&gt; optimize table &lt;表名&gt;;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://csxiaoyao.cn/index.html#/" target="_blank" rel="noopener">https://csxiaoyao.cn/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql MVCC（二）</title>
      <link href="/2019/07/31/Mysql-MVCC%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/07/31/Mysql-MVCC%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql-MVCC"><a href="#Mysql-MVCC" class="headerlink" title="Mysql MVCC"></a>Mysql MVCC</h1><p>MVCC是Multi Version Concurrency Control的简称，代表多版本并发控制。实现读不阻塞写，写不阻塞读</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">数据库事务的ACID特性:Atomicity(原子性), Consistency(一致性), Isolation(隔离性), Durability(持久性) </span><br><span class="line">* 原子性表示一个事务的操作结果要么全部执行要么全部不执行。</span><br><span class="line">* 一致性表示事务总是从一个一致的状态转换到另一个一致的状态。</span><br><span class="line">* 隔离性表示一个事务的修改结果在什么时间能够被其他事务看到，SQL1992规范中对隔离性定义了不同的隔离级别：</span><br><span class="line">    1.读未提交(READ UNCOMMITED)：事务能够看到其他事务没有提及的修改，可能出现dirty read。</span><br><span class="line">    2.读已提交(READ COMMITTED)：事务能够看到其他事务提交后的修改，这时会出现一个事务内两次读取数据可能因为其他事务提交的修改导致不一致的情况，称为不可重复读。 </span><br><span class="line">    3.可重复读(REPEATABLE READ)：在两次读取时读取到的数据的状态是一致的。</span><br><span class="line">    4.序列化(SERIALIZABLE)：可重复读中可能出现第二次读读到第一次没有读到的数据，也就是被其他事务插入的数据，这种情况称为幻读phantom read, 序列化级别中不能出现幻读。</span><br><span class="line">隔离级别依次增强，并发能力依次减弱。</span><br><span class="line"></span><br><span class="line">和Java中的多线程问题相同，数据库通常使用锁来实现隔离性。</span><br><span class="line">    1.读写锁</span><br><span class="line">    2.读写锁冲突解决：不同的事务session会看到自己特定版本的数据，即快照。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* binlog:常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的, 另外通过解析binlog能够实现mysql到其他数据源（如ElasticSearch)的数据复制。</span><br><span class="line">* redo log:记录了数据操作在物理层面的修改，mysql中使用了大量缓存，缓存存在于内存中，修改操作时会直接修改内存，而不是立刻修改磁盘，当内存和磁盘的数据不一致时，称内存中的数据为脏页(dirty page)。为了保证数据的安全性，事务进行中时会不断的产生redo log，在事务提交时进行一次flush操作，保存到磁盘中, redo log是按照顺序写入的，磁盘的顺序读写的速度远大于随机读写。当数据库或主机失效重启时，会根据redo log进行数据的恢复。</span><br><span class="line">* undo Log: 通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC。在Innodb中存在purge线程，它会查询那些比现在最老的活动事务还早的undo log，并删除它们，从而保证undo log文件不至于无限增长。</span><br></pre></td></tr></table></figure><p><img src="images/undolog.jpg" alt></p><p>InnoDB表会有三个隐藏字段</p><ul><li>6字节的DB_ROW_ID</li><li>6字节的DB_TX_ID</li><li>7字节的DB_ROLL_PTR </li></ul><p>在每个事务开始的时候，会将当前系统中的所有的活跃事务拷贝到一个列表中 (read view)，根据read view最早一个事务ID和最晚的一个事务ID来做比较的，这样就能确保在当前事务之前没有提交的所有事务的变更以及后续新启动的事务的变更，在当前事务中都是看不到的,本事务的变更可见。</p><p>###参考<br><a href="https://liuzhengyang.github.io/2017/04/18/innodb-mvcc/" target="_blank" rel="noopener">https://liuzhengyang.github.io/2017/04/18/innodb-mvcc/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 索引（一）</title>
      <link href="/2019/07/31/Mysql-%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/07/31/Mysql-%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql索引"><a href="#Mysql索引" class="headerlink" title="Mysql索引"></a>Mysql索引</h1>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mit6824-mapreduce</title>
      <link href="/2019/07/31/mit6824-mapreduce/"/>
      <url>/2019/07/31/mit6824-mapreduce/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 6824 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客过程</title>
      <link href="/2019/07/31/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/07/31/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo搭建GitHub博客"><a href="#Hexo搭建GitHub博客" class="headerlink" title="Hexo搭建GitHub博客"></a>Hexo搭建GitHub博客</h1><h3 id="安装NodeJS"><a href="#安装NodeJS" class="headerlink" title="安装NodeJS"></a>安装NodeJS</h3><p>NodeJS安装包下载地址 : <a href="https://nodejs.org/" target="_blank" rel="noopener">https://nodejs.org/</a></p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo -g</span><br></pre></td></tr></table></figure><h3 id="创建Hexo工程"><a href="#创建Hexo工程" class="headerlink" title="创建Hexo工程"></a>创建Hexo工程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><h3 id="使用NexT主题"><a href="#使用NexT主题" class="headerlink" title="使用NexT主题"></a>使用NexT主题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>_config.yml    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><h3 id="启动本地服务查看"><a href="#启动本地服务查看" class="headerlink" title="启动本地服务查看"></a>启动本地服务查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo serve --debug</span><br></pre></td></tr></table></figure><h3 id="github创建站点"><a href="#github创建站点" class="headerlink" title="github创建站点"></a>github创建站点</h3><p>创建 repository <strong>lluzt.github.io</strong></p><h3 id="github发布配置"><a href="#github发布配置" class="headerlink" title="github发布配置"></a>github发布配置</h3><p>_config.yml  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type:git</span><br><span class="line">  repo: git@github.com:lluzt/lluzt.github.io.git </span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h3 id="发布命令"><a href="#发布命令" class="headerlink" title="发布命令"></a>发布命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo serve</span><br><span class="line"></span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h3 id="图片显示"><a href="#图片显示" class="headerlink" title="图片显示"></a>图片显示</h3><h4 id="本地引用"><a href="#本地引用" class="headerlink" title="本地引用"></a>本地引用</h4><h5 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h5><p>当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source/images/image.jpg</span><br><span class="line"></span><br><span class="line">![](/images/image.jpg)</span><br></pre></td></tr></table></figure><p>图片既可以在首页内容中访问到，也可以在文章正文中访问到。</p><h5 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h5><p>图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br><span class="line"></span><br><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。</p><p><img src="image.jpg" alt><br>上述是markdown的引用方式，图片只能在文章中显示，但无法在首页中正常显示。</p><p>如果希望图片在文章和首页中同时显示，可以使用标签插件语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% asset_img image.jpg This is an image %&#125;</span><br></pre></td></tr></table></figure><h4 id="CDN引用"><a href="#CDN引用" class="headerlink" title="CDN引用"></a>CDN引用</h4><p>除了在本地存储图片，还可以将图片上传到一些免费的CDN服务中。比如Cloudinary提供的图片CDN服务，在Cloudinary中上传图片后，会生成对应的url地址，将地址直接拿来引用即可。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/" target="_blank" rel="noopener">https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/</a><br><a href="https://liuzhengyang.github.io/" target="_blank" rel="noopener">https://liuzhengyang.github.io/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>参考</title>
      <link href="/reference/index.html"/>
      <url>/reference/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
